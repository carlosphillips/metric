{"version":3,"sources":["reactjs:react/src/inject-react.js","reactjs:react/src/require-react.js","reactjs:react/src/ReactMeteor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,+B;AACA,6B;;AAEA,oB;AACA,uC;AACA,a;AACA,kB;AACA,W;AACA,uC;AACA,uC;AACA,mC;AACA,E;;AAEA,uB;AACA,4D;AACA,sC;AACA,C;;AAEA,+D;;;;;;;;;;;;;;;;;;;AClBA,oC;;;;;;;;;;;;;;;;;;;ACAA,wB;AACA,kC;AACA,oB;;AAEA,oD;AACA,gC;;AAEA,0B;AACA,6C;AACA,8C;AACA,sC;;AAEA,4C;AACA,0E;AACA,4E;AACA,0C;AACA,S;;AAEA,uC;AACA,S;;AAEA,Y;AACA,qC;AACA,K;AACA,I;;AAEA,uD;AACA,qC;AACA,yE;AACA,uE;AACA,oD;AACA,yC;AACA,a;AACA,K;;AAEA,+B;AACA,qC;AACA,K;AACA,I;;AAEA,oC;AACA,kC;AACA,qC;AACA,qC;AACA,K;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,+B;AACA,+B;;AAEA,uB;AACA,kE;AACA,iC;AACA,W;AACA,G;;AAEA,kC;AACA,yE;AACA,8D;AACA,sC;AACA,2C;AACA,qC;AACA,W;AACA,G;;AAEA,iC;AACA,2C;AACA,qC;AACA,K;AACA,C;;AAEA,mE;AACA,4D;AACA,wD;AACA,wC;AACA,oB;AACA,oB;AACA,sB;AACA,mC;;AAEA,iB;AACA,+B;AACA,sB;AACA,Y;AACA,uB;AACA,K;AACA,iC;AACA,iC;AACA,iB;AACA,G;;AAEA,qD;AACA,sC;;AAEA,4B;AACA,oC;AACA,4C;AACA,O;AACA,G;;AAEA,4B;AACA,oC;AACA,iC;AACA,O;AACA,G;;AAEA,gB;AACA,C;;AAEA,e;AACA,0B;;AAEA,8D;AACA,2C;AACA,oC;AACA,uC;AACA,sC;;AAEA,0B;AACA,yC;AACA,gD;AACA,kC;AACA,0B;AACA,oB;AACA,uE;AACA,8D;AACA,+B;AACA,S;AACA,Q;;AAEA,sC;AACA,4B;AACA,kD;AACA,oD;AACA,2B;AACA,U;AACA,S;;AAEA,6C;AACA,K;;AAEA,e;AACA,G;AACA,E","file":"/packages/reactjs_react.js","sourcesContent":["var path = Npm.require(\"path\");\nvar url = Npm.require(\"url\");\n\nvar src = path.join(\n  url.parse(process.env.ROOT_URL).path,\n  \"packages\",\n  \"reactjs_react\",\n  \"vendor\",\n  process.env.NODE_ENV === \"production\"\n    ? \"react-with-addons-0.13.0.min.js\"\n    : \"react-with-addons-0.13.0.js\"\n);\n\nif (path.sep !== \"/\") {\n  // On Windows, path.sep === \"\\\\\", so we must convert to /.\n  src = src.split(path.sep).join(\"/\");\n}\n\nInject.rawHead('react', '<script src=\"' + src + '\"></script>');\n","React = Npm.require(\"react/addons\");\n","var ReactMeteorMixin = {\n  componentWillMount: function() {\n    var self = this;\n\n    self._meteorStateDep = new Tracker.Dependency();\n    self._meteorFirstRun = true;\n\n    if (Meteor.isClient) {\n      Tracker.autorun(function(computation) {\n        self._meteorComputation = computation;\n        self._meteorStateDep.depend();\n\n        if (self.startMeteorSubscriptions) {\n          // Calling this method in a Tracker.autorun callback will ensure\n          // that the subscriptions are canceled when the computation stops.\n          self.startMeteorSubscriptions();\n        }\n\n        enqueueMeteorStateUpdate(self);\n      });\n\n    } else {\n      enqueueMeteorStateUpdate(self);\n    }\n  },\n\n  componentWillUpdate: function(nextProps, nextState) {\n    if (this._meteorCalledSetState) {\n      // If this component update was triggered by the ReactMeteor.Mixin,\n      // then we do not want to trigger the change event again, because\n      // that would lead to an infinite update loop.\n      this._meteorCalledSetState = false;\n      return;\n    }\n\n    if (this._meteorStateDep) {\n      this._meteorStateDep.changed();\n    }\n  },\n\n  componentWillUnmount: function() {\n    if (this._meteorComputation) {\n      this._meteorComputation.stop();\n      this._meteorComputation = null;\n    }\n  }\n};\n\nfunction enqueueMeteorStateUpdate(component) {\n  var partialState =\n    component.getMeteorState &&\n    component.getMeteorState();\n\n  if (! partialState) {\n    // The getMeteorState method can return a falsy value to avoid\n    // triggering a state update.\n    return;\n  }\n\n  if (component._meteorFirstRun) {\n    // If it's the first time we've called enqueueMeteorStateUpdate since\n    // the component was mounted, set the state synchronously.\n    component._meteorFirstRun = false;\n    component._meteorCalledSetState = true;\n    component.setState(partialState);\n    return;\n  }\n\n  Tracker.afterFlush(function() {\n    component._meteorCalledSetState = true;\n    component.setState(partialState);\n  });\n}\n\n// Like React.render, but it replaces targetNode, and works even if\n// targetNode.parentNode has children other than targetNode.\nfunction renderInPlaceOfNode(reactElement, targetNode) {\n  var container = targetNode.parentNode;\n  var prevSibs = [];\n  var nextSibs = [];\n  var sibs = prevSibs;\n  var child = container.firstChild;\n\n  while (child) {\n    if (child === targetNode) {\n      sibs = nextSibs;\n    } else {\n      sibs.push(child);\n    }\n    var next = child.nextSibling;\n    container.removeChild(child);\n    child = next;\n  }\n\n  var result = React.render(reactElement, container);\n  var rendered = container.firstChild;\n\n  if (prevSibs.length > 0) {\n    prevSibs.forEach(function(sib) {\n      container.insertBefore(sib, rendered);\n    });\n  }\n\n  if (nextSibs.length > 0) {\n    nextSibs.forEach(function(sib) {\n      container.appendChild(sib);\n    });\n  }\n\n  return result;\n}\n\nReactMeteor = {\n  Mixin: ReactMeteorMixin,\n\n  // So you don't have to mix in ReactMeteor.Mixin explicitly.\n  createClass: function createClass(spec) {\n    spec.mixins = spec.mixins || [];\n    spec.mixins.push(ReactMeteorMixin);\n    var Cls = React.createClass(spec);\n\n    if (Meteor.isClient &&\n        typeof Template === \"function\" &&\n        typeof spec.templateName === \"string\") {\n      var template = new Template(\n        spec.templateName,\n        function() {\n          // A placeholder HTML element that will serve as the mounting\n          // point for the React component. May have siblings!\n          return new HTML.SPAN;\n        }\n      );\n\n      template.onRendered(function() {\n        renderInPlaceOfNode(\n          // Equivalent to <Cls {...this.data} />:\n          React.createElement(Cls, this.data || {}),\n          this.find(\"span\")\n        );\n      });\n\n      Template[spec.templateName] = template;\n    }\n\n    return Cls;\n  }\n};\n"]}